
'use server';
/**
 * @fileOverview A flow for handling user chat interactions using OpenAI.
 *
 * - chat - An exported function that invokes the main chat flow.
 * - ChatInput - The Zod schema for the chat function's input.
 * - ChatOutput - The Zod schema for the chat function's output.
 */

import type { HistoryItem } from '@/ai/types';
import { getSystemPrompt } from '@/chatbot/chatbot-prompt';
import fs from 'fs/promises';
import path from 'path';
import { z } from 'zod';
import OpenAI from 'openai';

// Initialize OpenAI client
const openai = new OpenAI({
  apiKey: process.env.OPENAI_API_KEY,
});

// Zod schema for chat input
const ChatInputSchema = z.object({
  newUserMessage: z.string().describe('The latest message from the user.'),
  history: z.array(z.object({
    role: z.enum(['user', 'assistant']),
    content: z.string(),
  })).describe('The conversation history.'),
});
export type ChatInput = z.infer<typeof ChatInputSchema>;

// Zod schema for chat output
const ChatOutputSchema = z.object({
  text: z.string().describe('The AI-generated response.'),
  sessionLanguage: z.string().describe('The detected language code for the session.'),
});
export type ChatOutput = z.infer<typeof ChatOutputSchema>;


/**
 * Reads knowledge files from the filesystem to provide context to the AI.
 * @returns A string containing the combined content of all knowledge files.
 */
async function getKnowledgeContent(): Promise<string> {
    const knowledgeDirectory = path.join(process.cwd(), 'src', 'chatbot', 'IAsourcesPrompt');
    try {
        const files = await fs.readdir(knowledgeDirectory);
        const txtFiles = files.filter(file => file.endsWith('.txt'));
        
        let allContent = '';
        for (const file of txtFiles) {
            const filePath = path.join(knowledgeDirectory, file);
            const content = await fs.readFile(filePath, 'utf-8');
            allContent += `\n\n--- Start of ${file} ---\n${content}\n--- End of ${file} ---\n`;
        }
        return allContent;
    } catch (error) {
        console.error('Error reading knowledge files:', error);
        return ''; // Return empty string if there's an error
    }
}

/**
 * A simple language detector.
 * @param text The text to analyze.
 * @returns A two-letter language code (e.g., 'en', 'es').
 */
async function detectLanguage(text: string): Promise<string> {
    const lowerText = text.toLowerCase();
    if (/\b(hola|gracias|qué|cómo)\b/.test(lowerText)) return 'es';
    if (/\b(bonjour|merci|quoi|comment)\b/.test(lowerText)) return 'fr';
    // Add more simple rules as needed
    return 'en'; // Default to English
}


/**
 * An exported wrapper function that calls the OpenAI API.
 * This provides a clean interface for the UI components.
 */
export async function chat(
  newUserMessage: string, 
  history: HistoryItem[],
  sessionId: string, // Kept for API compatibility, not used by OpenAI directly
  sessionLanguage: string | null
): Promise<ChatOutput> {
    
    const languageCode = sessionLanguage || await detectLanguage(newUserMessage);
    const isFirstMessage = history.length === 0;

    try {
        const knowledgeContext = await getKnowledgeContent();
        const systemPromptContent = getSystemPrompt(knowledgeContext, languageCode, isFirstMessage);

        const messagesForAPI: OpenAI.Chat.Completions.ChatCompletionMessageParam[] = [
            { role: "system", content: systemPromptContent },
            ...history.map(h => ({
                role: h.role,
                content: h.content,
            })),
            { role: "user", content: newUserMessage },
        ];

        const completion = await openai.chat.completions.create({
            model: "gpt-4o", // Using the latest efficient model
            messages: messagesForAPI,
            temperature: 0.7,
        });

        const aiResponseText = completion.choices[0]?.message?.content;

        if (!aiResponseText) {
             throw new Error('No text was generated by the model.');
        }

        return {
            text: aiResponseText,
            sessionLanguage: languageCode,
        };
    } catch (error) {
       console.error('Error generating response from OpenAI:', error);
       const errorMessage = languageCode === 'es' 
                ? "Lo siento, no he podido conectar con el asistente en este momento. Por favor, inténtelo de nuevo más tarde." 
                : "Sorry, I couldn't connect to the assistant at this time. Please try again later.";
       return {
            text: errorMessage,
            sessionLanguage: languageCode,
       }
    }
}
